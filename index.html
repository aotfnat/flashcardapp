<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Study Cards</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#111111">

<style>
body {
  margin:0;
  font-family:-apple-system,BlinkMacSystemFont,sans-serif;
  background:#111;
  color:white;
}

/* Sidebar */
#sidebar {
  position:fixed;
  top:0;
  left:-280px;
  width:260px;
  height:100%;
  background:#1c1c1c;
  padding:20px;
  transition:left 0.3s;
  overflow-y:auto;
  z-index:1000;
}

#sidebar.open { left:0; }

#overlay {
  position:fixed;
  top:0; left:0;
  width:100%; height:100%;
  background:rgba(0,0,0,0.5);
  display:none;
}

#overlay.show { display:block; }

.menu-btn {
  position:fixed;
  top:15px;
  left:15px;
  font-size:22px;
  background:none;
  color:white;
  border:none;
}

.card {
  margin-top:80px;
  padding:40px;
  text-align:center;
  font-size:22px;
}

.study-btn {
  width:90%;
  margin:10px auto;
  padding:22px;
  font-size:18px;
  border:none;
  border-radius:10px;
  display:block;
}

.show { background:#333; color:white; }
.correct { background:#2e7d32; color:white; }
.incorrect { background:#c62828; color:white; }

.hidden { display:none; }

input, select {
  width:100%;
  padding:8px;
  margin:6px 0;
}
</style>
</head>
<body>

<button class="menu-btn" onclick="toggleMenu()">☰</button>

<div id="sidebar">
  <h3>Decks</h3>
  <div id="deckList"></div>

  <hr>

  <input id="newDeckName" placeholder="New Deck Name">
  <button onclick="addDeck()">Add Deck</button>

  <hr>

  <button onclick="restartDeck()">Restart Deck</button>
  <button onclick="deleteDeck()">Delete Deck</button>
  <button onclick="toggleMode()">Toggle Sequential/Shuffle</button>
  <button onclick="markDone()">Mark Deck Done ✔</button>

  <hr>

  <h4>Add Card</h4>
  <input id="newQ" placeholder="Question">
  <input id="newA" placeholder="Answer">
  <button onclick="addCard()">Add Card</button>

  <hr>

  <input type="file" id="csvFile">
  <button onclick="importCSV()">Import CSV</button>
</div>

<div id="overlay" onclick="toggleMenu()"></div>

<div class="card" id="card">Open menu and select a deck</div>

<button id="primaryBtn" class="study-btn show hidden" onclick="primaryAction()">Show Question</button>
<button id="correctBtn" class="study-btn correct hidden" onclick="grade(true)">Correct</button>
<button id="incorrectBtn" class="study-btn incorrect hidden" onclick="grade(false)">Incorrect</button>

<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('service-worker.js');
}

let data = JSON.parse(localStorage.getItem("studyData")) || { decks:{} };

let currentDeck=null;
let sessionCards=[];
let repeatQueue=[];
let index=0;
let firstQuestion=true;

function save(){ localStorage.setItem("studyData",JSON.stringify(data)); }

function toggleMenu(){
  sidebar.classList.toggle("open");
  overlay.classList.toggle("show");
}

function renderDecks(){
  deckList.innerHTML="";
  Object.keys(data.decks).forEach(name=>{
    const d=document.createElement("div");
    d.innerHTML=(data.decks[name].done?"✔ ":"")+name;
    d.onclick=()=>startDeck(name);
    deckList.appendChild(d);
  });
}
renderDecks();

function addDeck(){
  const name=newDeckName.value.trim();
  if(!name) return;
  data.decks[name]={cards:[],mode:"sequential",done:false};
  save();
  renderDecks();
}

function deleteDeck(){
  if(!currentDeck) return;
  delete data.decks[currentDeck];
  currentDeck=null;
  save();
  renderDecks();
  card.innerHTML="Deck deleted.";
}

function startDeck(name){
  currentDeck=name;
  firstQuestion=true;
  repeatQueue=[];
  sessionCards=[...data.decks[name].cards];
  if(data.decks[name].mode==="shuffle")
    sessionCards.sort(()=>Math.random()-0.5);
  index=0;
  primaryBtn.textContent="Show Question";
  primaryBtn.classList.remove("hidden");
  correctBtn.classList.add("hidden");
  incorrectBtn.classList.add("hidden");
  card.innerHTML="Ready.";
  toggleMenu();
}

function primaryAction(){
  if(firstQuestion){
    showQuestion();
    firstQuestion=false;
  } else {
    showAnswer();
  }
}

function showQuestion(){
  if(index>=sessionCards.length){
    if(repeatQueue.length>0){
      sessionCards=repeatQueue;
      repeatQueue=[];
      index=0;
    } else {
      card.innerHTML="Deck Complete.";
      return;
    }
  }
  card.innerHTML=sessionCards[index].q;
  primaryBtn.textContent="Show Answer";
}

function showAnswer(){
  card.innerHTML=sessionCards[index].a;
  primaryBtn.classList.add("hidden");
  correctBtn.classList.remove("hidden");
  incorrectBtn.classList.remove("hidden");
}

function grade(correct){
  if(!correct) repeatQueue.push(sessionCards[index]);
  index++;
  correctBtn.classList.add("hidden");
  incorrectBtn.classList.add("hidden");
  primaryBtn.classList.remove("hidden");
  primaryBtn.textContent="Show Answer";
  showQuestion();
}

function restartDeck(){
  if(!currentDeck) return;
  startDeck(currentDeck);
}

function toggleMode(){
  if(!currentDeck) return;
  const deck=data.decks[currentDeck];
  deck.mode=deck.mode==="sequential"?"shuffle":"sequential";
  save();
}

function markDone(){
  if(!currentDeck) return;
  data.decks[currentDeck].done=!data.decks[currentDeck].done;
  save();
  renderDecks();
}

function addCard(){
  if(!currentDeck) return;
  const q=newQ.value.trim();
  const a=newA.value.trim();
  if(!q||!a) return;
  data.decks[currentDeck].cards.push({q,a});
  newQ.value=""; newA.value="";
  save();
}

function parseCSV(text) {
  const rows = [];
  let current = '';
  let row = [];
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    const next = text[i + 1];

    if (char === '"' && inQuotes && next === '"') {
      current += '"';
      i++; // skip escaped quote
    } 
    else if (char === '"') {
      inQuotes = !inQuotes;
    } 
    else if (char === ',' && !inQuotes) {
      row.push(current.trim());
      current = '';
    } 
    else if ((char === '\n' || char === '\r') && !inQuotes) {
      if (current || row.length) {
        row.push(current.trim());
        rows.push(row);
        row = [];
        current = '';
      }
    } 
    else {
      current += char;
    }
  }

  if (current || row.length) {
    row.push(current.trim());
    rows.push(row);
  }

  return rows;
}

function importCSV(){
  const file = csvFile.files[0];
  if (!file) return;

  const deckName = file.name.replace(".csv","");
  if (!data.decks[deckName])
    data.decks[deckName] = {cards:[], mode:"sequential", done:false};

  const reader = new FileReader();
  reader.onload = e => {
    const rows = parseCSV(e.target.result);

    rows.forEach(r => {
      if (r.length >= 2) {
        data.decks[deckName].cards.push({
          q: r[0],
          a: r[1]
        });
      }
    });

    save();
    renderDecks();
    alert("Import complete.");
  };

  reader.readAsText(file);
}
  
</script>

</body>
</html>


