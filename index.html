<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>FlashCards</title>
<link rel="manifest" href="manifest.json">

<style>
body {
  margin:0;
  font-family:-apple-system,BlinkMacSystemFont,sans-serif;
  background:#111;
  color:white;
  text-align:center;
  overflow-x:hidden;
}

.bottom-bar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 16px 20px;
  background: #111;
  border-top: 1px solid #333;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  z-index: 100;
  box-sizing: border-box;
  padding-bottom: env(safe-area-inset-bottom, 16px);
}

button {
  padding: 16px;
  margin: 0;               /* remove previous margin */
  font-size: 17px;
  border-radius: 12px;
  width: 100%;
  max-width: 420px;
  box-sizing: border-box;
  touch-action: manipulation;   /* better touch response */
}

@media (min-width: 400px) {
  .bottom-bar {
    flex-direction: row;
    justify-content: center;
    gap: 16px;
    padding: 16px 24px;
  }
  
  .bottom-bar button {
    width: auto;
    min-width: 140px;
    flex: 1;
    max-width: 220px;
  }
}

#showBtn { background:#444; color:white; }
#correctBtn { background:#1e8e3e; display:none; }
#incorrectBtn { background:#c62828; display:none; }

.main-content-area {
  min-height: 100vh;
  padding: 60px 20px 180px;   /* top for menu button, bottom for bar */
  box-sizing: border-box;
}

#card {
  margin: 80px 20px 20px;
  font-size: 22px;
  min-height: 120px;
  
  /* Core changes */
  text-align: center;           /* centers inline content (including the inner block) */
  line-height: 1.45;
  
  /* Let the inner content take only the width it needs */
  display: flex;
  justify-content: center;      /* horizontal centering */
  align-items: center;          /* vertical centering — optional but nice */
}

#card > div.inner {             /* ← we'll wrap the text in a div */
  text-align: left;             /* left-align the actual lines */
  max-width: 90%;               /* or 85% / 480px / whatever feels best */
  width: fit-content;           /* shrinks to content width, but won't exceed max-width */
}

img {
  max-width:100%;
  margin-top:10px;
  border-radius:8px;
}

/* Sidebar */
menuBtn {
  position:fixed;
  top: 10px;
  left: 10px;
  font-size:26px;
  background:none;
  color:white;
  border:none;
  z-index:2000;
}

.sidebar {
  position:fixed;
  top:0;
  left:-260;
  width:260px;
  height:100%;
  background:#222;
  transform:translateX(-100%);
  transition:transform .3s ease;
  padding:20px;
  box-sizing:border-box;
  overflow-y:auto;
  z-index:1000;
}

.sidebar.open { transform:translateX(0); }

input, textarea, select {
  width:100%;
  margin:5px 0;
  padding:8px;
  border-radius:6px;
  border:none;
}

.deckItem {
  padding: 10px 12px;
  cursor: pointer;
  border-radius: 8px;
  margin: 4px 0;
  transition: all 0.15s ease;
}

.deckItem:hover {
  background: #333;
}

.deckItem.active {
  background: #444;
  color: #8bc34a;           /* light green for success/active feel */
  font-weight: bold;
  border-left: 4px solid #8bc34a;
  padding-left: 8px;        /* compensate for border width */
}

.deckItem.done {
  color: #66bb6a;
}

.deckItem.done::after {
  content: " ✔";
  color: #8bc34a;
}

.deckItem.done.active {
  background: #2e7d32;      /* darker green when both done + active */
  border-left-color: #a5d6a7;
}

</style>
</head>
<body>

<button class="menuBtn" onclick="toggleMenu()">☰</button>

<div class="sidebar" id="sidebar">
<h3>Decks</h3>
<div id="deckList"></div>

<button onclick="addDeck()">Add Deck</button>
<button onclick="deleteDeck()">Delete Deck</button>
<button onclick="restartDeck()">Restart Deck</button>
<button onclick="toggleMode()">Toggle Shuffle</button>
<button onclick="markDone()">Mark Done ✔</button>

<hr>

<h3>Import CSV</h3>
<input type="file" id="csvFile" accept=".csv">
<button onclick="importCSV()">Import</button>

<hr>

<h3>Add Card</h3>
<textarea id="newQ" placeholder="Question"></textarea>
<textarea id="newA" placeholder="Answer"></textarea>
<input type="file" id="newImg" accept="image/*">
<button onclick="addCard()">Add Card</button>

<hr>

<h3>Edit Cards</h3>
<div id="cardList"></div>
<div id="editor" style="display:none;">
<textarea id="editQ"></textarea>
<textarea id="editA"></textarea>
<input type="file" id="editImg" accept="image/*">
<button onclick="saveEdit()">Save</button>
<button onclick="deleteCard()">Delete</button>
</div>

</div>

<div class="main-content-area">

	<div id="card">Tap “Show Question” to begin</div>

</div>

<div class="bottom-bar">
  <button id="showBtn" onclick="handleShow()">Show Question</button>
  <button id="correctBtn" onclick="grade(true)">Correct</button>
  <button id="incorrectBtn" onclick="grade(false)">Incorrect</button>
</div>

<script>
let data = JSON.parse(localStorage.getItem("studyData")) || {decks:{}};
let currentDeck = null;
let currentIndex = 0;
let showingAnswer = false;
let firstShow = true;
let repeatQueue = [];
let editingIndex = null;

function save(){
  localStorage.setItem("studyData", JSON.stringify(data));
}

function nl2br(str) {
  if (!str) return '';
  // First escape HTML (prevent <script> etc.), then convert newlines
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/\n/g, '<br>');
}

function toggleMenu(){
  document.getElementById("sidebar").classList.toggle("open");
}

function renderDecks() {
  const list = document.getElementById("deckList");
  list.innerHTML = "";

  Object.keys(data.decks).forEach(name => {
    const div = document.createElement("div");
    div.textContent = name;
    div.className = "deckItem";

    // Add classes based on state
    if (data.decks[name].done) {
      div.classList.add("done");
    }
    if (name === currentDeck) {
      div.classList.add("active");
    }

    const cardCount = data.decks[name].cards.length;
    div.textContent = `${name} (${cardCount})`;

    div.onclick = () => {
      currentDeck = name;
      startSession();
      toggleMenu();           // optional: close sidebar after selection
      renderDecks();          // ← re-render to update highlight
    };

    list.appendChild(div);
  });
}

function addDeck() {
  const name = prompt("Deck name?");
  if (!name) return;

  // Initialize the deck and store a copy of the original cards
  const newDeck = {
    cards: [],
    originalCards: [],
    mode: "sequential",
    done: false,
    completed: false, // Track completion state
  };

  data.decks[name] = newDeck;
  save();
  renderDecks();
}

function deleteDeck(){
  if(!currentDeck) return;
  if(confirm("Delete deck?")){
    delete data.decks[currentDeck];
    currentDeck=null;
    save();
    renderDecks();
  }
}

function markDone(){
  if(!currentDeck) return;
  data.decks[currentDeck].done=!data.decks[currentDeck].done;
  save();
  renderDecks();
}

function toggleMode(){
  if(!currentDeck) return;
  const deck=data.decks[currentDeck];
  deck.mode = deck.mode==="shuffle" ? "sequential":"shuffle";
  save();
  alert("Mode: "+deck.mode);
}

function restartDeck(){
  startSession();
}

function startSession() {
  const deck = data.decks[currentDeck];
  // Reset button to normal "Show Question" behavior
  const showBtn = document.getElementById("showBtn");
  showBtn.innerText = "Show Question";
  showBtn.onclick = handleShow;               // ← restore original handler
  showBtn.style.display = "block";

  // Ensure originalCards is available before resetting
  if (!deck.originalCards || !Array.isArray(deck.originalCards)) {
    console.error("Error: originalCards is not properly initialized.");
    return;
  }

  // If the deck was completed previously, we will reset it with the original cards
  if (deck.completed) {
    deck.cards = [...deck.originalCards]; // Reset to the full deck from originalCards
    deck.completed = false;               // Mark the deck as not completed
  }

  currentIndex = 0;
  repeatQueue = []; // Reset the repeat queue (incorrect answers)
  showingAnswer = false;
  firstShow = true;
  
  // Set up the card display
  document.getElementById("card").innerText = 'Tap “Show Question” to begin';
  document.getElementById("showBtn").innerText = "Show Question";
  document.getElementById("showBtn").style.display = "block";
  document.getElementById("correctBtn").style.display = "none";
  document.getElementById("incorrectBtn").style.display = "none";

  renderDecks();   // ← ensures highlight updates if coming from restart/complete

}

function handleShow(){
  if(!currentDeck) return;
  const deck=data.decks[currentDeck];
  if(deck.cards.length===0){
    document.getElementById("card").innerText="No cards.";
    return;
  }

  if(firstShow){
    showQuestion();
    firstShow=false;
  } else if(!showingAnswer){
    showAnswer();
  }
}

function showQuestion(){
  const deck=data.decks[currentDeck];
  let cards=deck.cards;
  if(deck.mode==="shuffle"){
    currentIndex=Math.floor(Math.random()*cards.length);
  }
  const card=cards[currentIndex];
  let questionHtml = nl2br(card.q);   // assuming you have nl2br from before
  document.getElementById("card").innerHTML = 
    '<div class="inner">' + questionHtml + '</div>' +
    (card.img ? '<br><img src="' + card.img + '">' : "");
  document.getElementById("showBtn").innerText="Show Answer";
  showingAnswer=false;
}

function showAnswer(){
  const deck=data.decks[currentDeck];
  const card=deck.cards[currentIndex];
  let answerHtml = nl2br(card.a);
  document.getElementById("card").innerHTML = 
    '<div class="inner">' + answerHtml + '</div>' +
    (card.img ? '<br><img src="' + card.img + '">' : "");
  document.getElementById("showBtn").style.display="none";
  document.getElementById("correctBtn").style.display="block";
  document.getElementById("incorrectBtn").style.display="block";
  showingAnswer=true;
}

function grade(correct) {
  const deck = data.decks[currentDeck];
  if (!correct) {
    repeatQueue.push(deck.cards[currentIndex]); // Add incorrect cards to repeatQueue
  }

  document.getElementById("correctBtn").style.display = "none";
  document.getElementById("incorrectBtn").style.display = "none";
  document.getElementById("showBtn").style.display = "block";
  document.getElementById("showBtn").innerText = "Show Answer";

  currentIndex++;

// Check if all cards are done
  if (currentIndex >= deck.cards.length) {
    if (repeatQueue.length > 0) {
      deck.cards = repeatQueue;
      repeatQueue = [];
      currentIndex = 0;
      showQuestion();
    } else {
      deck.completed = true;
      document.getElementById("card").innerHTML = 
        '<strong>Deck Complete!</strong><br><br>';
      
      // Change button to "Restart Deck"
      const showBtn = document.getElementById("showBtn");
      showBtn.innerText = "Restart Deck";
      showBtn.onclick = restartDeck;           // ← override the click handler
      
      // Make sure other buttons are hidden
      document.getElementById("correctBtn").style.display = "none";
      document.getElementById("incorrectBtn").style.display = "none";
      showBtn.style.display = "block";
      
      return;
    }
  }

  showQuestion();
}


function parseCSV(text) {
  const rows = [];
  let row = [];
  let field = '';
  let inQuotes = false;
  let i = 0;

  // Add a sentinel newline at the end to flush the last field/row
  text += '\n';

  while (i < text.length) {
    const char = text[i];
    const next = text[i + 1] || '';

    if (char === '"' && inQuotes && next === '"') {
      // Escaped quote inside quoted field → keep one "
      field += '"';
      i += 2;
      continue;
    }

    if (char === '"') {
      inQuotes = !inQuotes;
      i++;
      continue;
    }

    if (char === ',' && !inQuotes) {
      row.push(field.trim());
      field = '';
      i++;
      continue;
    }

    if ((char === '\n' || char === '\r') && !inQuotes) {
      // End of row (only if not inside quotes)
      if (char === '\r' && next === '\n') i++; // skip LF after CR
      row.push(field.trim());
      if (row.some(v => v !== '')) {   // skip completely empty rows
        rows.push(row);
      }
      row = [];
      field = '';
      i++;
      continue;
    }

    // Normal character
    field += char;
    i++;
  }

  // Final flush if file didn't end with newline
  if (field || row.length) {
    row.push(field.trim());
    if (row.some(v => v !== '')) {
      rows.push(row);
    }
  }

  return rows;
}

function importCSV() {
  const file = document.getElementById("csvFile").files[0];
  if (!file) return;

  const deckName = file.name.replace(".csv", "");
  
  // Initialize the deck if it doesn't exist
  if (!data.decks[deckName]) {
    data.decks[deckName] = { cards: [], originalCards: [], mode: "sequential", done: false };
  }

  const reader = new FileReader();
  reader.onload = (e) => {
    const rows = parseCSV(e.target.result);
    
    // Add the cards to the deck and also initialize originalCards
    rows.forEach(r => {
      if (r.length >= 2) {
        const card = { q: r[0], a: r[1], img: null };
        data.decks[deckName].cards.push(card);
        data.decks[deckName].originalCards.push(card); // Ensure originalCards is populated
      }
    });

    save();
    renderDecks();
    alert("Import complete.");
  };
  reader.readAsText(file);
}

function addCard() {
  if (!currentDeck) return;
  const q = document.getElementById("newQ").value;
  const a = document.getElementById("newA").value;
  const imgFile = document.getElementById("newImg").files[0];

  const card = { q, a, img: null };

  if (imgFile) {
    const reader = new FileReader();
    reader.onload = e => {
      card.img = e.target.result;
      const deck = data.decks[currentDeck];
      deck.cards.push(card);
      deck.originalCards.push(card); // Save a copy of the original card
      save();
      renderDecks();
    };
    reader.readAsDataURL(imgFile);
  } else {
    const deck = data.decks[currentDeck];
    deck.cards.push(card);
    deck.originalCards.push(card); // Save a copy of the original card
    save();
    renderDecks();
  }
}

renderDecks();

if (!currentDeck && Object.keys(data.decks).length > 0) {
  currentDeck = Object.keys(data.decks)[0];  // auto-select first deck
  startSession();
}

</script>
</body>
</html>
