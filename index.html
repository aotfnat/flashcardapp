<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>FlashCards</title>
<link rel="manifest" href="manifest.json">

<style>
body {
  margin:0;
  font-family:-apple-system,BlinkMacSystemFont,sans-serif;
  background:#111;
  color:white;
  text-align:center;
  overflow-x:hidden;
}

button {
  padding:18px;
  margin:8px;
  font-size:18px;
  border:none;
  border-radius:10px;
  width:90%;
  max-width:500px;
}

#showBtn { background:#444; color:white; }
#correctBtn { background:#1e8e3e; display:none; }
#incorrectBtn { background:#c62828; display:none; }

#card {
  margin:80px 20px 20px;
  font-size:22px;
  min-height:120px;
}

img {
  max-width:100%;
  margin-top:10px;
  border-radius:8px;
}

/* Sidebar */
menuBtn {
  position:fixed;
  top: 10px;
  left: 10px;
  font-size:26px;
  background:none;
  color:white;
  border:none;
  z-index:2000;
}

.sidebar {
  position:fixed;
  top:0;
  left:-260;
  width:260px;
  height:100%;
  background:#222;
  transform:translateX(-100%);
  transition:transform .3s ease;
  padding:20px;
  box-sizing:border-box;
  overflow-y:auto;
  z-index:1000;
}

.sidebar.open { transform:translateX(0); }


input, textarea, select {
  width:100%;
  margin:5px 0;
  padding:8px;
  border-radius:6px;
  border:none;
}

.deckItem {
  padding:6px;
  cursor:pointer;
}

.deckItem.done::after {
  content:" ✔";
  color:#1e8e3e;
}
</style>
</head>
<body>

<button class="menuBtn" onclick="toggleMenu()">☰</button>

<div class="sidebar" id="sidebar">
<h3>Decks</h3>
<div id="deckList"></div>

<button onclick="addDeck()">Add Deck</button>
<button onclick="deleteDeck()">Delete Deck</button>
<button onclick="restartDeck()">Restart Deck</button>
<button onclick="toggleMode()">Toggle Shuffle</button>
<button onclick="markDone()">Mark Done ✔</button>

<hr>

<h3>Import CSV</h3>
<input type="file" id="csvFile" accept=".csv">
<button onclick="importCSV()">Import</button>

<hr>

<h3>Add Card</h3>
<textarea id="newQ" placeholder="Question"></textarea>
<textarea id="newA" placeholder="Answer"></textarea>
<input type="file" id="newImg" accept="image/*">
<button onclick="addCard()">Add Card</button>

<hr>

<h3>Edit Cards</h3>
<div id="cardList"></div>
<div id="editor" style="display:none;">
<textarea id="editQ"></textarea>
<textarea id="editA"></textarea>
<input type="file" id="editImg" accept="image/*">
<button onclick="saveEdit()">Save</button>
<button onclick="deleteCard()">Delete</button>
</div>

</div>

<div id="card">Tap “Show Question” to begin</div>

<button id="showBtn" onclick="handleShow()">Show Question</button>
<button id="correctBtn" onclick="grade(true)">Correct</button>
<button id="incorrectBtn" onclick="grade(false)">Incorrect</button>

<script>
let data = JSON.parse(localStorage.getItem("studyData")) || {decks:{}};
let currentDeck = null;
let currentIndex = 0;
let showingAnswer = false;
let firstShow = true;
let repeatQueue = [];
let editingIndex = null;

function save(){
  localStorage.setItem("studyData", JSON.stringify(data));
}

function toggleMenu(){
  document.getElementById("sidebar").classList.toggle("open");
}

function renderDecks(){
  const list = document.getElementById("deckList");
  list.innerHTML="";
  Object.keys(data.decks).forEach(name=>{
    const div=document.createElement("div");
    div.textContent=name;
    div.className="deckItem";
    if(data.decks[name].done) div.classList.add("done");
    div.onclick=()=>{
      currentDeck=name;
      startSession();
      toggleMenu();
    };
    list.appendChild(div);
  });
}

function addDeck() {
  const name = prompt("Deck name?");
  if (!name) return;

  // Initialize the deck and store a copy of the original cards
  const newDeck = {
    cards: [],
    originalCards: [],
    mode: "sequential",
    done: false,
    completed: false, // Track completion state
  };

  data.decks[name] = newDeck;
  save();
  renderDecks();
}

function deleteDeck(){
  if(!currentDeck) return;
  if(confirm("Delete deck?")){
    delete data.decks[currentDeck];
    currentDeck=null;
    save();
    renderDecks();
  }
}

function markDone(){
  if(!currentDeck) return;
  data.decks[currentDeck].done=!data.decks[currentDeck].done;
  save();
  renderDecks();
}

function toggleMode(){
  if(!currentDeck) return;
  const deck=data.decks[currentDeck];
  deck.mode = deck.mode==="shuffle" ? "sequential":"shuffle";
  save();
  alert("Mode: "+deck.mode);
}

function restartDeck(){
  startSession();
}

function startSession() {
  const deck = data.decks[currentDeck];

  // Ensure originalCards is available before resetting
  if (!deck.originalCards || !Array.isArray(deck.originalCards)) {
    console.error("Error: originalCards is not properly initialized.");
    return;
  }

  // If the deck was completed previously, we will reset it with the original cards
  if (deck.completed) {
    deck.cards = [...deck.originalCards]; // Reset to the full deck from originalCards
    deck.completed = false;               // Mark the deck as not completed
  }

  currentIndex = 0;
  repeatQueue = []; // Reset the repeat queue (incorrect answers)
  showingAnswer = false;
  firstShow = true;
  
  // Set up the card display
  document.getElementById("card").innerText = 'Tap “Show Question” to begin';
  document.getElementById("showBtn").innerText = "Show Question";
  document.getElementById("showBtn").style.display = "block";
  document.getElementById("correctBtn").style.display = "none";
  document.getElementById("incorrectBtn").style.display = "none";
}

function handleShow(){
  if(!currentDeck) return;
  const deck=data.decks[currentDeck];
  if(deck.cards.length===0){
    document.getElementById("card").innerText="No cards.";
    return;
  }

  if(firstShow){
    showQuestion();
    firstShow=false;
  } else if(!showingAnswer){
    showAnswer();
  }
}

function showQuestion(){
  const deck=data.decks[currentDeck];
  let cards=deck.cards;
  if(deck.mode==="shuffle"){
    currentIndex=Math.floor(Math.random()*cards.length);
  }
  const card=cards[currentIndex];
  document.getElementById("card").innerHTML=card.q+(card.img?'<br><img src="'+card.img+'">':"");
  document.getElementById("showBtn").innerText="Show Answer";
  showingAnswer=false;
}

function showAnswer(){
  const deck=data.decks[currentDeck];
  const card=deck.cards[currentIndex];
  document.getElementById("card").innerHTML=card.a+(card.img?'<br><img src="'+card.img+'">':"");
  document.getElementById("showBtn").style.display="none";
  document.getElementById("correctBtn").style.display="block";
  document.getElementById("incorrectBtn").style.display="block";
  showingAnswer=true;
}

function grade(correct) {
  const deck = data.decks[currentDeck];
  if (!correct) {
    repeatQueue.push(deck.cards[currentIndex]); // Add incorrect cards to repeatQueue
  }

  document.getElementById("correctBtn").style.display = "none";
  document.getElementById("incorrectBtn").style.display = "none";
  document.getElementById("showBtn").style.display = "block";
  document.getElementById("showBtn").innerText = "Show Answer";

  currentIndex++;

  // Check if all cards are done
  if (currentIndex >= deck.cards.length) {
    if (repeatQueue.length > 0) {
      deck.cards = repeatQueue; // Use only repeat cards if there are any
      repeatQueue = [];         // Clear repeat queue after cycling through incorrect answers
      currentIndex = 0;         // Restart at the first repeat card
    } else {
      deck.completed = true;    // Mark deck as completed when all cards are correctly answered
      document.getElementById("card").innerText = "Deck Complete!";
      return;
    }
  }

  showQuestion();
}

/* ---------- CSV PARSER ---------- */

function parseCSV(text) {
  const rows = [];
  let current = '';
  let row = [];
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    const next = text[i + 1];

    if (char === '"' && inQuotes && next === '"') {
      current += '"';
      i++;
    } 
    else if (char === '"') {
      inQuotes = !inQuotes;
    } 
    else if (char === ',' && !inQuotes) {
      row.push(current.trim());
      current = '';
    } 
    else if ((char === '\n' || char === '\r') && !inQuotes) {
      if (current || row.length) {
        row.push(current.trim());
        rows.push(row);
        row = [];
        current = '';
      }
    } 
    else {
      current += char;
    }
  }

  if (current || row.length) {
    row.push(current.trim());
    rows.push(row);
  }

  return rows;
}

function importCSV() {
  const file = document.getElementById("csvFile").files[0];
  if (!file) return;

  const deckName = file.name.replace(".csv", "");
  
  // Initialize the deck if it doesn't exist
  if (!data.decks[deckName]) {
    data.decks[deckName] = { cards: [], originalCards: [], mode: "sequential", done: false };
  }

  const reader = new FileReader();
  reader.onload = (e) => {
    const rows = parseCSV(e.target.result);
    
    // Add the cards to the deck and also initialize originalCards
    rows.forEach(r => {
      if (r.length >= 2) {
        const card = { q: r[0], a: r[1], img: null };
        data.decks[deckName].cards.push(card);
        data.decks[deckName].originalCards.push(card); // Ensure originalCards is populated
      }
    });

    save();
    renderDecks();
    alert("Import complete.");
  };
  reader.readAsText(file);
}

function addCard() {
  if (!currentDeck) return;
  const q = document.getElementById("newQ").value;
  const a = document.getElementById("newA").value;
  const imgFile = document.getElementById("newImg").files[0];

  const card = { q, a, img: null };

  if (imgFile) {
    const reader = new FileReader();
    reader.onload = e => {
      card.img = e.target.result;
      const deck = data.decks[currentDeck];
      deck.cards.push(card);
      deck.originalCards.push(card); // Save a copy of the original card
      save();
      renderDecks();
    };
    reader.readAsDataURL(imgFile);
  } else {
    const deck = data.decks[currentDeck];
    deck.cards.push(card);
    deck.originalCards.push(card); // Save a copy of the original card
    save();
    renderDecks();
  }
}

renderDecks();
</script>
</body>
</html>
